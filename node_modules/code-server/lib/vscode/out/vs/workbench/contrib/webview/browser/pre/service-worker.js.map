{"version":3,"sources":["out-vscode-reh-web/vs/workbench/contrib/webview/browser/pre/service-worker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n//@ts-check\n/// <reference lib=\"webworker\" />\n\n/** @type {ServiceWorkerGlobalScope} */\nconst sw = /** @type {any} */ (self);\n\nconst VERSION = 4;\n\nconst resourceCacheName = `vscode-resource-cache-${VERSION}`;\n\nconst rootPath = sw.location.pathname.replace(/\\/service-worker.js$/, '');\n\nconst searchParams = new URL(location.toString()).searchParams;\n\nconst remoteAuthority = searchParams.get('remoteAuthority');\n\n/** @type {MessagePort|undefined} */\nlet outerIframeMessagePort;\n\n/**\n * Origin used for resources\n */\nconst resourceBaseAuthority = searchParams.get('vscode-resource-base-authority');\n\n/**\n * @param {string} name\n * @param {Record<string, string>} [options]\n */\nconst perfMark = (name, options = {}) => {\n\tperformance.mark(`webview/service-worker/${name}`, {\n\t\tdetail: {\n\t\t\t...options\n\t\t}\n\t});\n}\n\nperfMark('scriptStart');\n\n/** @type {number} */\nconst resolveTimeout = 30_000;\n\n\n/**\n * @template T\n * @typedef {{ status: 'ok', value: T } | { status: 'timeout' }} RequestStoreResult\n */\n\n\n/**\n * @template T\n * @typedef {{ resolve: (x: RequestStoreResult<T>) => void, promise: Promise<RequestStoreResult<T>> }} RequestStoreEntry\n */\n\n\n/**\n * @template T\n */\nclass RequestStore {\n\tconstructor() {\n\t\t/** @type {Map<number, RequestStoreEntry<T>>} */\n\t\tthis.map = new Map();\n\t\t/** @type {number} */\n\t\tthis.requestPool = 0;\n\t}\n\n\t/**\n\t * @returns {{ requestId: number, promise: Promise<RequestStoreResult<T>> }}\n\t */\n\tcreate() {\n\t\tconst requestId = ++this.requestPool;\n\n\t\t/** @type {(x: RequestStoreResult<T>) => void} */\n\t\tlet resolve;\n\t\tconst promise = new Promise(r => resolve = r);\n\n\t\t/** @type {RequestStoreEntry<T>} */\n\t\tconst entry = { resolve, promise };\n\t\tthis.map.set(requestId, entry);\n\n\t\tconst dispose = () => {\n\t\t\tclearTimeout(timeout);\n\t\t\tconst existingEntry = this.map.get(requestId);\n\t\t\tif (existingEntry === entry) {\n\t\t\t\texistingEntry.resolve({ status: 'timeout' });\n\t\t\t\tthis.map.delete(requestId);\n\t\t\t}\n\t\t};\n\t\tconst timeout = setTimeout(dispose, resolveTimeout);\n\t\treturn { requestId, promise };\n\t}\n\n\t/**\n\t * @param {number} requestId\n\t * @param {T} result\n\t * @returns {boolean}\n\t */\n\tresolve(requestId, result) {\n\t\tconst entry = this.map.get(requestId);\n\t\tif (!entry) {\n\t\t\treturn false;\n\t\t}\n\t\tentry.resolve({ status: 'ok', value: result });\n\t\tthis.map.delete(requestId);\n\t\treturn true;\n\t}\n}\n\n/**\n * Map of requested paths to responses.\n */\n/** @type {RequestStore<ResourceResponse>} */\nconst resourceRequestStore = new RequestStore();\n\n/**\n * Map of requested localhost origins to optional redirects.\n */\n/** @type {RequestStore<string|undefined>} */\nconst localhostRequestStore = new RequestStore();\n\nconst unauthorized = () =>\n\tnew Response('Unauthorized', { status: 401, });\n\nconst notFound = () =>\n\tnew Response('Not Found', { status: 404, });\n\nconst methodNotAllowed = () =>\n\tnew Response('Method Not Allowed', { status: 405, });\n\nconst requestTimeout = () =>\n\tnew Response('Request Timeout', { status: 408, });\n\nsw.addEventListener('message', async (event) => {\n\tif (!event.source) {\n\t\treturn;\n\t}\n\n\t/** @type {Client} */\n\tconst source = event.source;\n\tswitch (event.data.channel) {\n\t\tcase 'version': {\n\t\t\tperfMark('version/request');\n\t\t\touterIframeMessagePort = event.ports[0];\n\t\t\tsw.clients.get(source.id).then(client => {\n\t\t\t\tperfMark('version/reply');\n\t\t\t\tif (client) {\n\t\t\t\t\tclient.postMessage({\n\t\t\t\t\t\tchannel: 'version',\n\t\t\t\t\t\tversion: VERSION\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tcase 'did-load-resource': {\n\t\t\t/** @type {ResourceResponse} */\n\t\t\tconst response = event.data.data;\n\t\t\tif (!resourceRequestStore.resolve(response.id, response)) {\n\t\t\t\tconsole.log('Could not resolve unknown resource', response.path);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tcase 'did-load-localhost': {\n\t\t\tconst data = event.data.data;\n\t\t\tif (!localhostRequestStore.resolve(data.id, data.location)) {\n\t\t\t\tconsole.log('Could not resolve unknown localhost', data.origin);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.log('Unknown message');\n\t\t\treturn;\n\t\t}\n\t}\n});\n\nsw.addEventListener('fetch', (event) => {\n\tconst requestUrl = new URL(event.request.url);\n\tif (typeof resourceBaseAuthority === 'string' && requestUrl.protocol === 'https:' && requestUrl.hostname.endsWith('.' + resourceBaseAuthority)) {\n\t\tswitch (event.request.method) {\n\t\t\tcase 'GET':\n\t\t\tcase 'HEAD': {\n\t\t\t\tconst firstHostSegment = requestUrl.hostname.slice(0, requestUrl.hostname.length - (resourceBaseAuthority.length + 1));\n\t\t\t\tconst scheme = firstHostSegment.split('+', 1)[0];\n\t\t\t\tconst authority = firstHostSegment.slice(scheme.length + 1); // may be empty\n\t\t\t\treturn event.respondWith(processResourceRequest(event, {\n\t\t\t\t\tscheme,\n\t\t\t\t\tauthority,\n\t\t\t\t\tpath: requestUrl.pathname,\n\t\t\t\t\tquery: requestUrl.search.replace(/^\\?/, ''),\n\t\t\t\t}));\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn event.respondWith(methodNotAllowed());\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we're making a request against the remote authority, we want to go\n\t// through VS Code itself so that we are authenticated properly.  If the\n\t// service worker is hosted on the same origin we will have cookies and\n\t// authentication will not be an issue.\n\tif (requestUrl.origin !== sw.origin && requestUrl.host === remoteAuthority) {\n\t\tswitch (event.request.method) {\n\t\t\tcase 'GET':\n\t\t\tcase 'HEAD': {\n\t\t\t\treturn event.respondWith(processResourceRequest(event, {\n\t\t\t\t\tpath: requestUrl.pathname,\n\t\t\t\t\tscheme: requestUrl.protocol.slice(0, requestUrl.protocol.length - 1),\n\t\t\t\t\tauthority: requestUrl.host,\n\t\t\t\t\tquery: requestUrl.search.replace(/^\\?/, ''),\n\t\t\t\t}));\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn event.respondWith(methodNotAllowed());\n\t\t\t}\n\t\t}\n\t}\n\n\t// See if it's a localhost request\n\tif (requestUrl.origin !== sw.origin && requestUrl.host.match(/^(localhost|127.0.0.1|0.0.0.0):(\\d+)$/)) {\n\t\treturn event.respondWith(processLocalhostRequest(event, requestUrl));\n\t}\n});\n\nsw.addEventListener('install', (event) => {\n\tevent.waitUntil(sw.skipWaiting()); // Activate worker immediately\n});\n\nsw.addEventListener('activate', (event) => {\n\tevent.waitUntil(sw.clients.claim()); // Become available to all pages\n});\n\n\n/**\n * @typedef {Object} ResourceRequestUrlComponents\n * @property {string} scheme\n * @property {string} authority\n * @property {string} path\n * @property {string} query\n */\n\n/**\n * @param {FetchEvent} event\n * @param {ResourceRequestUrlComponents} requestUrlComponents\n * @returns {Promise<Response>}\n */\nasync function processResourceRequest(\n\tevent,\n\trequestUrlComponents\n) {\n\tlet client = await sw.clients.get(event.clientId);\n\tif (!client) {\n\t\tclient = await getWorkerClientForId(event.clientId);\n\t\tif (!client) {\n\t\t\tconsole.error('Could not find inner client for request');\n\t\t\treturn notFound();\n\t\t}\n\t}\n\n\tconst webviewId = getWebviewIdForClient(client);\n\n\t// Refs https://github.com/microsoft/vscode/issues/244143\n\t// With PlzDedicatedWorker, worker subresources and blob wokers\n\t// will use clients different from the window client.\n\t// Since we cannot different a worker main resource from a worker subresource\n\t// we will use message channel to the outer iframe provided at the time\n\t// of service worker controller version initialization.\n\tif (!webviewId && client.type !== 'worker' && client.type !== 'sharedworker') {\n\t\tconsole.error('Could not resolve webview id');\n\t\treturn notFound();\n\t}\n\n\tconst shouldTryCaching = (event.request.method === 'GET');\n\n\t/**\n\t * @param {RequestStoreResult<ResourceResponse>} result\n\t * @param {Response|undefined} cachedResponse\n\t * @returns {Response}\n\t */\n\tconst resolveResourceEntry = (result, cachedResponse) => {\n\t\tif (result.status === 'timeout') {\n\t\t\treturn requestTimeout();\n\t\t}\n\n\t\tconst entry = result.value;\n\t\tif (entry.status === 304) { // Not modified\n\t\t\tif (cachedResponse) {\n\t\t\t\treturn cachedResponse.clone();\n\t\t\t} else {\n\t\t\t\tthrow new Error('No cache found');\n\t\t\t}\n\t\t}\n\n\t\tif (entry.status === 401) {\n\t\t\treturn unauthorized();\n\t\t}\n\n\t\tif (entry.status !== 200) {\n\t\t\treturn notFound();\n\t\t}\n\n\t\t/** @type {Record<string, string>} */\n\t\tconst commonHeaders = {\n\t\t\t'Access-Control-Allow-Origin': '*',\n\t\t};\n\n\t\tconst byteLength = entry.data.byteLength;\n\n\t\tconst range = event.request.headers.get('range');\n\t\tif (range) {\n\t\t\t// To support seeking for videos, we need to handle range requests\n\t\t\tconst bytes = range.match(/^bytes\\=(\\d+)\\-(\\d+)?$/g);\n\t\t\tif (bytes) {\n\t\t\t\t// TODO: Right now we are always reading the full file content. This is a bad idea\n\t\t\t\t// for large video files :)\n\n\t\t\t\tconst start = Number(bytes[1]);\n\t\t\t\tconst end = Number(bytes[2]) || byteLength - 1;\n\t\t\t\treturn new Response(entry.data.slice(start, end + 1), {\n\t\t\t\t\tstatus: 206,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t...commonHeaders,\n\t\t\t\t\t\t'Content-range': `bytes 0-${end}/${byteLength}`,\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// We don't understand the requested bytes\n\t\t\t\treturn new Response(null, {\n\t\t\t\t\tstatus: 416,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t...commonHeaders,\n\t\t\t\t\t\t'Content-range': `*/${byteLength}`\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Record<string, string>} */\n\t\tconst headers = {\n\t\t\t...commonHeaders,\n\t\t\t'Content-Type': entry.mime,\n\t\t\t'Content-Length': byteLength.toString(),\n\t\t};\n\n\t\tif (entry.etag) {\n\t\t\theaders['ETag'] = entry.etag;\n\t\t\theaders['Cache-Control'] = 'no-cache';\n\t\t}\n\t\tif (entry.mtime) {\n\t\t\theaders['Last-Modified'] = new Date(entry.mtime).toUTCString();\n\t\t}\n\n\t\t// support COI requests, see network.ts#COI.getHeadersFromQuery(...)\n\t\tconst coiRequest = new URL(event.request.url).searchParams.get('vscode-coi');\n\t\tif (coiRequest === '3') {\n\t\t\theaders['Cross-Origin-Opener-Policy'] = 'same-origin';\n\t\t\theaders['Cross-Origin-Embedder-Policy'] = 'require-corp';\n\t\t} else if (coiRequest === '2') {\n\t\t\theaders['Cross-Origin-Embedder-Policy'] = 'require-corp';\n\t\t} else if (coiRequest === '1') {\n\t\t\theaders['Cross-Origin-Opener-Policy'] = 'same-origin';\n\t\t}\n\n\t\tconst response = new Response(entry.data, {\n\t\t\tstatus: 200,\n\t\t\theaders\n\t\t});\n\n\t\tif (shouldTryCaching && entry.etag) {\n\t\t\tcaches.open(resourceCacheName).then(cache => {\n\t\t\t\treturn cache.put(event.request, response);\n\t\t\t});\n\t\t}\n\t\treturn response.clone();\n\t};\n\n\t/** @type {Response|undefined} */\n\tlet cached;\n\tif (shouldTryCaching) {\n\t\tconst cache = await caches.open(resourceCacheName);\n\t\tcached = await cache.match(event.request);\n\t}\n\n\tconst { requestId, promise } = resourceRequestStore.create();\n\n\tif (webviewId) {\n\t\tconst parentClients = await getOuterIframeClient(webviewId);\n\t\tif (!parentClients.length) {\n\t\t\tconsole.log('Could not find parent client for request');\n\t\t\treturn notFound();\n\t\t}\n\n\t\tfor (const parentClient of parentClients) {\n\t\t\tparentClient.postMessage({\n\t\t\t\tchannel: 'load-resource',\n\t\t\t\tid: requestId,\n\t\t\t\tscheme: requestUrlComponents.scheme,\n\t\t\t\tauthority: requestUrlComponents.authority,\n\t\t\t\tpath: requestUrlComponents.path,\n\t\t\t\tquery: requestUrlComponents.query,\n\t\t\t\tifNoneMatch: cached?.headers.get('ETag'),\n\t\t\t});\n\t\t}\n\t} else if (client.type === 'worker' || client.type === 'sharedworker') {\n\t\touterIframeMessagePort?.postMessage({\n\t\t\tchannel: 'load-resource',\n\t\t\tid: requestId,\n\t\t\tscheme: requestUrlComponents.scheme,\n\t\t\tauthority: requestUrlComponents.authority,\n\t\t\tpath: requestUrlComponents.path,\n\t\t\tquery: requestUrlComponents.query,\n\t\t\tifNoneMatch: cached?.headers.get('ETag'),\n\t\t});\n\t}\n\n\treturn promise.then(entry => resolveResourceEntry(entry, cached));\n}\n\n/**\n * @param {FetchEvent} event\n * @param {URL} requestUrl\n * @returns {Promise<Response>}\n */\nasync function processLocalhostRequest(\n\tevent,\n\trequestUrl\n) {\n\tconst client = await sw.clients.get(event.clientId);\n\tif (!client) {\n\t\t// This is expected when requesting resources on other localhost ports\n\t\t// that are not spawned by vs code\n\t\treturn fetch(event.request);\n\t}\n\tconst webviewId = getWebviewIdForClient(client);\n\t// Refs https://github.com/microsoft/vscode/issues/244143\n\t// With PlzDedicatedWorker, worker subresources and blob wokers\n\t// will use clients different from the window client.\n\t// Since we cannot different a worker main resource from a worker subresource\n\t// we will use message channel to the outer iframe provided at the time\n\t// of service worker controller version initialization.\n\tif (!webviewId && client.type !== 'worker' && client.type !== 'sharedworker') {\n\t\tconsole.error('Could not resolve webview id');\n\t\treturn fetch(event.request);\n\t}\n\n\tconst origin = requestUrl.origin;\n\n\t/**\n\t * @param {RequestStoreResult<string|undefined>} result\n\t * @returns {Promise<Response>}\n\t */\n\tconst resolveRedirect = async function (result) {\n\t\tif (result.status !== 'ok' || !result.value) {\n\t\t\treturn fetch(event.request);\n\t\t}\n\n\t\tconst redirectOrigin = result.value;\n\t\tconst location = event.request.url.replace(new RegExp(`^${requestUrl.origin}(/|$)`), `${redirectOrigin}$1`);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: location\n\t\t\t}\n\t\t});\n\t};\n\n\tconst { requestId, promise } = localhostRequestStore.create();\n\tif (webviewId) {\n\t\tconst parentClients = await getOuterIframeClient(webviewId);\n\t\tif (!parentClients.length) {\n\t\t\tconsole.log('Could not find parent client for request');\n\t\t\treturn notFound();\n\t\t}\n\t\tfor (const parentClient of parentClients) {\n\t\t\tparentClient.postMessage({\n\t\t\t\tchannel: 'load-localhost',\n\t\t\t\torigin: origin,\n\t\t\t\tid: requestId,\n\t\t\t});\n\t\t}\n\t} else if (client.type === 'worker' || client.type === 'sharedworker') {\n\t\touterIframeMessagePort?.postMessage({\n\t\t\tchannel: 'load-localhost',\n\t\t\torigin: origin,\n\t\t\tid: requestId,\n\t\t});\n\t}\n\n\treturn promise.then(resolveRedirect);\n}\n\n/**\n * @param {Client} client\n * @returns {string|null}\n */\nfunction getWebviewIdForClient(client) {\n\tconst requesterClientUrl = new URL(client.url);\n\treturn requesterClientUrl.searchParams.get('id');\n}\n\n/**\n * @param {string} webviewId\n * @returns {Promise<Client[]>}\n */\nasync function getOuterIframeClient(webviewId) {\n\tconst allClients = await sw.clients.matchAll({ includeUncontrolled: true });\n\treturn allClients.filter(client => {\n\t\tconst clientUrl = new URL(client.url);\n\t\tconst hasExpectedPathName = (clientUrl.pathname === `${rootPath}/` || clientUrl.pathname === `${rootPath}/index.html` || clientUrl.pathname === `${rootPath}/index-no-csp.html`);\n\t\treturn hasExpectedPathName && clientUrl.searchParams.get('id') === webviewId;\n\t});\n}\n\n/**\n * @param {string} clientId\n * @returns {Promise<Client|undefined>}\n */\nasync function getWorkerClientForId(clientId) {\n\tconst allDedicatedWorkerClients = await sw.clients.matchAll({ type: 'worker' });\n\tconst allSharedWorkerClients = await sw.clients.matchAll({ type: 'sharedworker' });\n\tconst allWorkerClients = [...allDedicatedWorkerClients, ...allSharedWorkerClients];\n\treturn allWorkerClients.find(client => {\n\t\treturn client.id === clientId;\n\t});\n}\n\n\n/**\n * @typedef {(\n *   | { readonly status: 200, id: number, path: string, mime: string, data: Uint8Array, etag: string|undefined, mtime: number|undefined }\n *   | { readonly status: 304, id: number, path: string, mime: string, mtime: number|undefined }\n *   | { readonly status: 401, id: number, path: string }\n *   | { readonly status: 404, id: number, path: string }\n * )} ResourceResponse\n */\n"],"mappings":"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","names":["name","options","requestId","resolve","promise","r","entry","timeout","existingEntry","result","event","source","client","response","data","requestUrl","firstHostSegment","scheme","authority","requestUrlComponents","webviewId","shouldTryCaching","resolveResourceEntry","cachedResponse","commonHeaders","byteLength","range","bytes","start","end","headers","coiRequest","cache","cached","parentClients","parentClient","origin","resolveRedirect","redirectOrigin","location","clientUrl","clientId","allDedicatedWorkerClients","allSharedWorkerClients"],"file":"service-worker.js"}